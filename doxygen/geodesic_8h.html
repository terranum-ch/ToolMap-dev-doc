<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ToolMap: /github/workspace/src/components/geodesic/geodesic.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<!---->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
	DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
	DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ToolMap
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('geodesic_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">geodesic.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Header for the geodesic routines in C.  
<a href="#details">More...</a></p>

<p><a href="geodesic_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgeod__geodesic.html">geod_geodesic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgeod__geodesicline.html">geod_geodesicline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgeod__polygon.html">geod_polygon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa1ab60cc36acda46bf5a36912798d301"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#aa1ab60cc36acda46bf5a36912798d301">GEODESIC_VERSION_MAJOR</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aa1ab60cc36acda46bf5a36912798d301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c184207064c950e11388ef12c7a055c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a0c184207064c950e11388ef12c7a055c">GEODESIC_VERSION_MINOR</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a0c184207064c950e11388ef12c7a055c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd9945ba2bb3fade45faa3bc017f6ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a4bd9945ba2bb3fade45faa3bc017f6ad">GEODESIC_VERSION_PATCH</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a4bd9945ba2bb3fade45faa3bc017f6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a13d1d4e7ad788044ac154396cb8ffa6e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6e">geod_mask</a> { <br />
&#160;&#160;<a class="el" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6eae22ae71ca672ded9811711bbee94378c">GEOD_NONE</a> = 0U
, <a class="el" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6ea4a91360f17ece136774405203fc82a77">GEOD_LATITUDE</a> = 1U &lt;&lt; 7 | 0U
, <a class="el" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6ea31db22e3891097a65a5dbacde93bc9b9">GEOD_LONGITUDE</a> = 1U &lt;&lt; 8 | 1U &lt;&lt; 3
, <a class="el" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6ea133a763df7edb34abac009ac5bc68198">GEOD_AZIMUTH</a> = 1U &lt;&lt; 9 | 0U
, <br />
&#160;&#160;<a class="el" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6eacc5dba1694d33678aaa88319b3031e1b">GEOD_DISTANCE</a> = 1U &lt;&lt; 10 | 1U &lt;&lt; 0
, <a class="el" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6eadbbfce582c4a7e3a2151c8db8d3561ca">GEOD_DISTANCE_IN</a> = 1U &lt;&lt; 11 | 1U &lt;&lt; 0 | 1U &lt;&lt; 1
, <a class="el" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6ea187e51906b0c056ac163a1ce7bfa7bde">GEOD_REDUCEDLENGTH</a> = 1U &lt;&lt; 12 | 1U &lt;&lt; 0 | 1U &lt;&lt; 2
, <a class="el" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6eac093650099cfb32655d9324bfbc2de8e">GEOD_GEODESICSCALE</a> = 1U &lt;&lt; 13 | 1U &lt;&lt; 0 | 1U &lt;&lt; 2
, <br />
&#160;&#160;<a class="el" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6eabd3942ee2187ea3db94652e995e9fefa">GEOD_AREA</a> = 1U &lt;&lt; 14 | 1U &lt;&lt; 4
, <a class="el" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6eab690c7b683ec89508b0797535c5a2130">GEOD_ALL</a> = 0x7F80U | 0x1FU
<br />
 }</td></tr>
<tr class="separator:a13d1d4e7ad788044ac154396cb8ffa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ace6823e6a47719d500f1a063e4255e5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init</a> (struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *g, double a, double f)</td></tr>
<tr class="separator:ace6823e6a47719d500f1a063e4255e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e376205aa792afe7ab50d6ef7d3435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a09e376205aa792afe7ab50d6ef7d3435">geod_lineinit</a> (struct <a class="el" href="structgeod__geodesicline.html">geod_geodesicline</a> *l, const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *g, double lat1, double lon1, double azi1, unsigned caps)</td></tr>
<tr class="separator:a09e376205aa792afe7ab50d6ef7d3435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676f59f07987ddd3dd4109fcfeccdb9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a676f59f07987ddd3dd4109fcfeccdb9d">geod_direct</a> (const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *g, double lat1, double lon1, double azi1, double s12, double *plat2, double *plon2, double *pazi2)</td></tr>
<tr class="separator:a676f59f07987ddd3dd4109fcfeccdb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bc3d000428010ad9d8509174e672c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a19bc3d000428010ad9d8509174e672c9">geod_inverse</a> (const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *g, double lat1, double lon1, double lat2, double lon2, double *ps12, double *pazi1, double *pazi2)</td></tr>
<tr class="separator:a19bc3d000428010ad9d8509174e672c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639904c52fc74105d084ec679988ccb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a639904c52fc74105d084ec679988ccb6">geod_position</a> (const struct <a class="el" href="structgeod__geodesicline.html">geod_geodesicline</a> *l, double s12, double *plat2, double *plon2, double *pazi2)</td></tr>
<tr class="separator:a639904c52fc74105d084ec679988ccb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31959a079115ec0440482e4aa124b556"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a31959a079115ec0440482e4aa124b556">geod_gendirect</a> (const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *g, double lat1, double lon1, double azi1, int arcmode, double s12_a12, double *plat2, double *plon2, double *pazi2, double *ps12, double *pm12, double *pM12, double *pM21, double *pS12)</td></tr>
<tr class="separator:a31959a079115ec0440482e4aa124b556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f22c8aef9d1f2a8b13aebea4e8cae3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a73f22c8aef9d1f2a8b13aebea4e8cae3">geod_geninverse</a> (const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *g, double lat1, double lon1, double lat2, double lon2, double *ps12, double *pazi1, double *pazi2, double *pm12, double *pM12, double *pM21, double *pS12)</td></tr>
<tr class="separator:a73f22c8aef9d1f2a8b13aebea4e8cae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85679144e60bddbad4e142c3918d7803"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a85679144e60bddbad4e142c3918d7803">geod_genposition</a> (const struct <a class="el" href="structgeod__geodesicline.html">geod_geodesicline</a> *l, int arcmode, double s12_a12, double *plat2, double *plon2, double *pazi2, double *ps12, double *pm12, double *pM12, double *pM21, double *pS12)</td></tr>
<tr class="separator:a85679144e60bddbad4e142c3918d7803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bcc76a7597c0431d7eb1b2a60b5fc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a35bcc76a7597c0431d7eb1b2a60b5fc5">geod_polygon_init</a> (struct <a class="el" href="structgeod__polygon.html">geod_polygon</a> *p, int polylinep)</td></tr>
<tr class="separator:a35bcc76a7597c0431d7eb1b2a60b5fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8efc9ecc11362c7ce2b67909d20eeaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#ae8efc9ecc11362c7ce2b67909d20eeaf">geod_polygon_addpoint</a> (const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *g, struct <a class="el" href="structgeod__polygon.html">geod_polygon</a> *p, double lat, double lon)</td></tr>
<tr class="separator:ae8efc9ecc11362c7ce2b67909d20eeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a039bd09181fad7b5238bef1a3a667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a18a039bd09181fad7b5238bef1a3a667">geod_polygon_addedge</a> (const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *g, struct <a class="el" href="structgeod__polygon.html">geod_polygon</a> *p, double azi, double s)</td></tr>
<tr class="separator:a18a039bd09181fad7b5238bef1a3a667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f0bc17da7f4304b059733917d11c4f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a82f0bc17da7f4304b059733917d11c4f">geod_polygon_compute</a> (const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *g, const struct <a class="el" href="structgeod__polygon.html">geod_polygon</a> *p, int reverse, int sign, double *pA, double *pP)</td></tr>
<tr class="separator:a82f0bc17da7f4304b059733917d11c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d95ee1a89aca82ac8d364ad4163e769"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a2d95ee1a89aca82ac8d364ad4163e769">geod_polygon_testpoint</a> (const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *g, const struct <a class="el" href="structgeod__polygon.html">geod_polygon</a> *p, double lat, double lon, int reverse, int sign, double *pA, double *pP)</td></tr>
<tr class="separator:a2d95ee1a89aca82ac8d364ad4163e769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b07aebad98323e339656343fa68d2d"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#a55b07aebad98323e339656343fa68d2d">geod_polygon_testedge</a> (const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *g, const struct <a class="el" href="structgeod__polygon.html">geod_polygon</a> *p, double azi, double s, int reverse, int sign, double *pA, double *pP)</td></tr>
<tr class="separator:a55b07aebad98323e339656343fa68d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa25f138d78c387a107ec0221bbb181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="geodesic_8h.html#aafa25f138d78c387a107ec0221bbb181">geod_polygonarea</a> (const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *g, double lats[], double lons[], int n, double *pA, double *pP)</td></tr>
<tr class="separator:aafa25f138d78c387a107ec0221bbb181"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Header for the geodesic routines in C. </p>
<p >This an implementation in C of the geodesic algorithms described in</p><ul>
<li>C. F. F. Karney, <a href="http://dx.doi.org/10.1007/s00190-012-0578-z">Algorithms for geodesics</a>, J. Geodesy <b>87</b>, 43&ndash;55 (2013); DOI: <a href="http://dx.doi.org/10.1007/s00190-012-0578-z">10.1007/s00190-012-0578-z</a>; addenda: <a href="http://geographiclib.sf.net/geod-addenda.html">geod-addenda.html</a>.</li>
</ul>
<p>The principal advantages of these algorithms over previous ones (e.g., Vincenty, 1975) are</p><ul>
<li>accurate to round off for |<em>f</em>| &lt; 1/50;</li>
<li>the solution of the inverse problem is always found;</li>
<li>differential and integral properties of geodesics are computed.</li>
</ul>
<p >The shortest path between two points on the ellipsoid at (<em>lat1</em>, <em>lon1</em>) and (<em>lat2</em>, <em>lon2</em>) is called the geodesic. Its length is <em>s12</em> and the geodesic from point 1 to point 2 has forward azimuths <em>azi1</em> and <em>azi2</em> at the two end points.</p>
<p >Traditionally two geodesic problems are considered:</p><ul>
<li>the direct problem &ndash; given <em>lat1</em>, <em>lon1</em>, <em>s12</em>, and <em>azi1</em>, determine <em>lat2</em>, <em>lon2</em>, and <em>azi2</em>. This is solved by the function <a class="el" href="geodesic_8h.html#a676f59f07987ddd3dd4109fcfeccdb9d">geod_direct()</a>.</li>
<li>the inverse problem &ndash; given <em>lat1</em>, <em>lon1</em>, and <em>lat2</em>, <em>lon2</em>, determine <em>s12</em>, <em>azi1</em>, and <em>azi2</em>. This is solved by the function <a class="el" href="geodesic_8h.html#a19bc3d000428010ad9d8509174e672c9">geod_inverse()</a>.</li>
</ul>
<p >The ellipsoid is specified by its equatorial radius <em>a</em> (typically in meters) and flattening <em>f</em>. The routines are accurate to round off with double precision arithmetic provided that |<em>f</em>| &lt; 1/50; for the WGS84 ellipsoid, the errors are less than 15 nanometers. (Reasonably accurate results are obtained for |<em>f</em>| &lt; 1/5.) For a prolate ellipsoid, specify <em>f</em> &lt; 0.</p>
<p >The routines also calculate several other quantities of interest</p><ul>
<li><em>S12</em> is the area between the geodesic from point 1 to point 2 and the equator; i.e., it is the area, measured counter-clockwise, of the quadrilateral with corners (<em>lat1</em>,<em>lon1</em>), (0,<em>lon1</em>), (0,<em>lon2</em>), and (<em>lat2</em>,<em>lon2</em>).</li>
<li><em>m12</em>, the reduced length of the geodesic is defined such that if the initial azimuth is perturbed by <em>dazi1</em> (radians) then the second point is displaced by <em>m12</em> <em>dazi1</em> in the direction perpendicular to the geodesic. On a curved surface the reduced length obeys a symmetry relation, <em>m12</em> + <em>m21</em> = 0. On a flat surface, we have <em>m12</em> = <em>s12</em>.</li>
<li><em>M12</em> and <em>M21</em> are geodesic scales. If two geodesics are parallel at point 1 and separated by a small distance <em>dt</em>, then they are separated by a distance <em>M12</em> <em>dt</em> at point 2. <em>M21</em> is defined similarly (with the geodesics being parallel to one another at point 2). On a flat surface, we have <em>M12</em> = <em>M21</em> = 1.</li>
<li><em>a12</em> is the arc length on the auxiliary sphere. This is a construct for converting the problem to one in spherical trigonometry. <em>a12</em> is measured in degrees. The spherical arc length from one equator crossing to the next is always 180&deg;.</li>
</ul>
<p >If points 1, 2, and 3 lie on a single geodesic, then the following addition rules hold:</p><ul>
<li><em>s13</em> = <em>s12</em> + <em>s23</em> </li>
<li><em>a13</em> = <em>a12</em> + <em>a23</em> </li>
<li><em>S13</em> = <em>S12</em> + <em>S23</em> </li>
<li><em>m13</em> = <em>m12</em> <em>M23</em> + <em>m23</em> <em>M21</em> </li>
<li><em>M13</em> = <em>M12</em> <em>M23</em> &minus; (1 &minus; <em>M12</em> <em>M21</em>) <em>m23</em> / <em>m12</em> </li>
<li><em>M31</em> = <em>M32</em> <em>M21</em> &minus; (1 &minus; <em>M23</em> <em>M32</em>) <em>m12</em> / <em>m23</em> </li>
</ul>
<p >The shortest distance returned by the solution of the inverse problem is (obviously) uniquely defined. However, in a few special cases there are multiple azimuths which yield the same shortest distance. Here is a catalog of those cases:</p><ul>
<li><em>lat1</em> = &minus;<em>lat2</em> (with neither at a pole). If <em>azi1</em> = <em>azi2</em>, the geodesic is unique. Otherwise there are two geodesics and the second one is obtained by setting [<em>azi1</em>, <em>azi2</em>] = [<em>azi2</em>, <em>azi1</em>], [<em>M12</em>, <em>M21</em>] = [<em>M21</em>, <em>M12</em>], <em>S12</em> = &minus;<em>S12</em>. (This occurs when the longitude difference is near &plusmn;180&deg; for oblate ellipsoids.)</li>
<li><em>lon2</em> = <em>lon1</em> &plusmn; 180&deg; (with neither at a pole). If <em>azi1</em> = 0&deg; or &plusmn;180&deg;, the geodesic is unique. Otherwise there are two geodesics and the second one is obtained by setting [<em>azi1</em>, <em>azi2</em>] = [&minus;<em>azi1</em>, &minus;<em>azi2</em>], <em>S12</em> = &minus;<em>S12</em>. (This occurs when the <em>lat2</em> is near &minus;<em>lat1</em> for prolate ellipsoids.)</li>
<li>Points 1 and 2 at opposite poles. There are infinitely many geodesics which can be generated by setting [<em>azi1</em>, <em>azi2</em>] = [<em>azi1</em>, <em>azi2</em>] + [<em>d</em>, &minus;<em>d</em>], for arbitrary <em>d</em>. (For spheres, this prescription applies when points 1 and 2 are antipodal.)</li>
<li><em>s12</em> = 0 (coincident points). There are infinitely many geodesics which can be generated by setting [<em>azi1</em>, <em>azi2</em>] = [<em>azi1</em>, <em>azi2</em>] + [<em>d</em>, <em>d</em>], for arbitrary <em>d</em>.</li>
</ul>
<p >These routines are a simple transcription of the corresponding C++ classes in <a href="http://geographiclib.sf.net">GeographicLib</a>. The "class
data" is represented by the structs <a class="el" href="structgeod__geodesic.html">geod_geodesic</a>, <a class="el" href="structgeod__geodesicline.html">geod_geodesicline</a>, <a class="el" href="structgeod__polygon.html">geod_polygon</a> and pointers to these objects are passed as initial arguments to the member functions. Most of the internal comments have been retained. However, in the process of transcription some documentation has been lost and the documentation for the C++ classes, GeographicLib::Geodesic, GeographicLib::GeodesicLine, and GeographicLib::PolygonArea, should be consulted. The C++ code remains the "reference implementation". Think twice about restructuring the internals of the C code since this may make porting fixes from the C++ code more difficult.</p>
<p >Copyright (c) Charles Karney (2012-2013) <a href="#" onclick="location.href='mai'+'lto:'+'cha'+'rl'+'es@'+'ka'+'rne'+'y.'+'com'; return false;">charl<span class="obfuscator">.nosp@m.</span>es@k<span class="obfuscator">.nosp@m.</span>arney<span class="obfuscator">.nosp@m.</span>.com</a> and licensed under the MIT/X11 License. For more information, see <a href="http://geographiclib.sourceforge.net/">http://geographiclib.sourceforge.net/</a></p>
<p >This library was distributed with <a href="../index.html">GeographicLib</a> 1.32. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aa1ab60cc36acda46bf5a36912798d301" name="aa1ab60cc36acda46bf5a36912798d301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ab60cc36acda46bf5a36912798d301">&#9670;&#160;</a></span>GEODESIC_VERSION_MAJOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEODESIC_VERSION_MAJOR&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The major version of the geodesic library. (This tracks the version of GeographicLib.) </p>

</div>
</div>
<a id="a0c184207064c950e11388ef12c7a055c" name="a0c184207064c950e11388ef12c7a055c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c184207064c950e11388ef12c7a055c">&#9670;&#160;</a></span>GEODESIC_VERSION_MINOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEODESIC_VERSION_MINOR&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The minor version of the geodesic library. (This tracks the version of GeographicLib.) </p>

</div>
</div>
<a id="a4bd9945ba2bb3fade45faa3bc017f6ad" name="a4bd9945ba2bb3fade45faa3bc017f6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd9945ba2bb3fade45faa3bc017f6ad">&#9670;&#160;</a></span>GEODESIC_VERSION_PATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEODESIC_VERSION_PATCH&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The patch level of the geodesic library. (This tracks the version of GeographicLib.) </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a13d1d4e7ad788044ac154396cb8ffa6e" name="a13d1d4e7ad788044ac154396cb8ffa6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d1d4e7ad788044ac154396cb8ffa6e">&#9670;&#160;</a></span>geod_mask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6e">geod_mask</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >mask values for the the <em>caps</em> argument to <a class="el" href="geodesic_8h.html#a09e376205aa792afe7ab50d6ef7d3435">geod_lineinit()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a13d1d4e7ad788044ac154396cb8ffa6eae22ae71ca672ded9811711bbee94378c" name="a13d1d4e7ad788044ac154396cb8ffa6eae22ae71ca672ded9811711bbee94378c"></a>GEOD_NONE&#160;</td><td class="fielddoc"><p >Calculate nothing </p>
</td></tr>
<tr><td class="fieldname"><a id="a13d1d4e7ad788044ac154396cb8ffa6ea4a91360f17ece136774405203fc82a77" name="a13d1d4e7ad788044ac154396cb8ffa6ea4a91360f17ece136774405203fc82a77"></a>GEOD_LATITUDE&#160;</td><td class="fielddoc"><p >Calculate latitude </p>
</td></tr>
<tr><td class="fieldname"><a id="a13d1d4e7ad788044ac154396cb8ffa6ea31db22e3891097a65a5dbacde93bc9b9" name="a13d1d4e7ad788044ac154396cb8ffa6ea31db22e3891097a65a5dbacde93bc9b9"></a>GEOD_LONGITUDE&#160;</td><td class="fielddoc"><p >Calculate longitude </p>
</td></tr>
<tr><td class="fieldname"><a id="a13d1d4e7ad788044ac154396cb8ffa6ea133a763df7edb34abac009ac5bc68198" name="a13d1d4e7ad788044ac154396cb8ffa6ea133a763df7edb34abac009ac5bc68198"></a>GEOD_AZIMUTH&#160;</td><td class="fielddoc"><p >Calculate azimuth </p>
</td></tr>
<tr><td class="fieldname"><a id="a13d1d4e7ad788044ac154396cb8ffa6eacc5dba1694d33678aaa88319b3031e1b" name="a13d1d4e7ad788044ac154396cb8ffa6eacc5dba1694d33678aaa88319b3031e1b"></a>GEOD_DISTANCE&#160;</td><td class="fielddoc"><p >Calculate distance </p>
</td></tr>
<tr><td class="fieldname"><a id="a13d1d4e7ad788044ac154396cb8ffa6eadbbfce582c4a7e3a2151c8db8d3561ca" name="a13d1d4e7ad788044ac154396cb8ffa6eadbbfce582c4a7e3a2151c8db8d3561ca"></a>GEOD_DISTANCE_IN&#160;</td><td class="fielddoc"><p >Allow distance as input <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a13d1d4e7ad788044ac154396cb8ffa6ea187e51906b0c056ac163a1ce7bfa7bde" name="a13d1d4e7ad788044ac154396cb8ffa6ea187e51906b0c056ac163a1ce7bfa7bde"></a>GEOD_REDUCEDLENGTH&#160;</td><td class="fielddoc"><p >Calculate reduced length </p>
</td></tr>
<tr><td class="fieldname"><a id="a13d1d4e7ad788044ac154396cb8ffa6eac093650099cfb32655d9324bfbc2de8e" name="a13d1d4e7ad788044ac154396cb8ffa6eac093650099cfb32655d9324bfbc2de8e"></a>GEOD_GEODESICSCALE&#160;</td><td class="fielddoc"><p >Calculate geodesic scale </p>
</td></tr>
<tr><td class="fieldname"><a id="a13d1d4e7ad788044ac154396cb8ffa6eabd3942ee2187ea3db94652e995e9fefa" name="a13d1d4e7ad788044ac154396cb8ffa6eabd3942ee2187ea3db94652e995e9fefa"></a>GEOD_AREA&#160;</td><td class="fielddoc"><p >Calculate reduced length </p>
</td></tr>
<tr><td class="fieldname"><a id="a13d1d4e7ad788044ac154396cb8ffa6eab690c7b683ec89508b0797535c5a2130" name="a13d1d4e7ad788044ac154396cb8ffa6eab690c7b683ec89508b0797535c5a2130"></a>GEOD_ALL&#160;</td><td class="fielddoc"><p >Calculate everything </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a676f59f07987ddd3dd4109fcfeccdb9d" name="a676f59f07987ddd3dd4109fcfeccdb9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676f59f07987ddd3dd4109fcfeccdb9d">&#9670;&#160;</a></span>geod_direct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geod_direct </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>azi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>plat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>plon2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pazi2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the direct geodesic problem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>a pointer to the <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> object specifying the ellipsoid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lat1</td><td>latitude of point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lon1</td><td>longitude of point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">azi1</td><td>azimuth at point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s12</td><td>distance between point 1 and point 2 (meters); it can be negative. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plat2</td><td>pointer to the latitude of point 2 (degrees). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plon2</td><td>pointer to the longitude of point 2 (degrees). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pazi2</td><td>pointer to the (forward) azimuth at point 2 (degrees).</td></tr>
  </table>
  </dd>
</dl>
<p><em>g</em> must have been initialized with a call to <a class="el" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init()</a>. <em>lat1</em> should be in the range [&minus;90&deg;, 90&deg;]; <em>lon1</em> and <em>azi1</em> should be in the range [&minus;540&deg;, 540&deg;). The values of <em>lon2</em> and <em>azi2</em> returned are in the range [&minus;180&deg;, 180&deg;). Any of the "return" arguments <em>plat2</em>, etc., may be replaced by 0, if you do not need some quantities computed.</p>
<p >If either point is at a pole, the azimuth is defined by keeping the longitude fixed, writing <em>lat</em> = &plusmn;(90&deg; &minus; &epsilon;), and taking the limit &epsilon; &rarr; 0+. An arc length greater that 180&deg; signifies a geodesic which is not a shortest path. (For a prolate ellipsoid, an additional condition is necessary for a shortest path: the longitudinal extent must not exceed of 180&deg;.)</p>
<p >Example, determine the point 10000 km NE of JFK: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structgeod__geodesic.html">geod_geodesic</a> g;</div>
<div class="line"><span class="keywordtype">double</span> lat, lon;</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init</a>(&amp;g, 6378137, 1/298.257223563);</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#a676f59f07987ddd3dd4109fcfeccdb9d">geod_direct</a>(&amp;g, 40.64, -73.78, 45.0, 10e6, &amp;lat, &amp;lon, 0);</div>
<div class="line">printf(<span class="stringliteral">&quot;%.5f %.5f\n&quot;</span>, lat, lon);</div>
<div class="ttc" id="ageodesic_8h_html_a676f59f07987ddd3dd4109fcfeccdb9d"><div class="ttname"><a href="geodesic_8h.html#a676f59f07987ddd3dd4109fcfeccdb9d">geod_direct</a></div><div class="ttdeci">void geod_direct(const struct geod_geodesic *g, double lat1, double lon1, double azi1, double s12, double *plat2, double *plon2, double *pazi2)</div></div>
<div class="ttc" id="ageodesic_8h_html_ace6823e6a47719d500f1a063e4255e5f"><div class="ttname"><a href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init</a></div><div class="ttdeci">void geod_init(struct geod_geodesic *g, double a, double f)</div></div>
<div class="ttc" id="astructgeod__geodesic_html"><div class="ttname"><a href="structgeod__geodesic.html">geod_geodesic</a></div><div class="ttdef"><b>Definition:</b> geodesic.h:146</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a31959a079115ec0440482e4aa124b556" name="a31959a079115ec0440482e4aa124b556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31959a079115ec0440482e4aa124b556">&#9670;&#160;</a></span>geod_gendirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double geod_gendirect </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>azi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arcmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s12_a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>plat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>plon2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pazi2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ps12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pm12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pM12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pM21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pS12</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The general direct geodesic problem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>a pointer to the <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> object specifying the ellipsoid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lat1</td><td>latitude of point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lon1</td><td>longitude of point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">azi1</td><td>azimuth at point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arcmode</td><td>flag determining the meaning of the <em>s12_a12</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s12_a12</td><td>if <em>arcmode</em> is 0, this is the distance between point 1 and point 2 (meters); otherwise it is the arc length between point 1 and point 2 (degrees); it can be negative. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plat2</td><td>pointer to the latitude of point 2 (degrees). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plon2</td><td>pointer to the longitude of point 2 (degrees). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pazi2</td><td>pointer to the (forward) azimuth at point 2 (degrees). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ps12</td><td>pointer to the distance between point 1 and point 2 (meters). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pm12</td><td>pointer to the reduced length of geodesic (meters). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pM12</td><td>pointer to the geodesic scale of point 2 relative to point 1 (dimensionless). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pM21</td><td>pointer to the geodesic scale of point 1 relative to point 2 (dimensionless). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pS12</td><td>pointer to the area under the geodesic (meters<sup>2</sup>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>a12</em> arc length of between point 1 and point 2 (degrees).</dd></dl>
<p><em>g</em> must have been initialized with a call to <a class="el" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init()</a>. <em>lat1</em> should be in the range [&minus;90&deg;, 90&deg;]; <em>lon1</em> and <em>azi1</em> should be in the range [&minus;540&deg;, 540&deg;). The function value <em>a12</em> equals <em>s12_a12</em> is <em>arcmode</em> is non-zero. Any of the "return" arguments <em>plat2</em>, etc., may be replaced by 0, if you do not need some quantities computed. </p>

</div>
</div>
<a id="a73f22c8aef9d1f2a8b13aebea4e8cae3" name="a73f22c8aef9d1f2a8b13aebea4e8cae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f22c8aef9d1f2a8b13aebea4e8cae3">&#9670;&#160;</a></span>geod_geninverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double geod_geninverse </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ps12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pazi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pazi2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pm12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pM12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pM21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pS12</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The general inverse geodesic calculation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>a pointer to the <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> object specifying the ellipsoid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lat1</td><td>latitude of point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lon1</td><td>longitude of point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lat2</td><td>latitude of point 2 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lon2</td><td>longitude of point 2 (degrees). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ps12</td><td>pointer to the distance between point 1 and point 2 (meters). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pazi1</td><td>pointer to the azimuth at point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pazi2</td><td>pointer to the (forward) azimuth at point 2 (degrees). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pm12</td><td>pointer to the reduced length of geodesic (meters). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pM12</td><td>pointer to the geodesic scale of point 2 relative to point 1 (dimensionless). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pM21</td><td>pointer to the geodesic scale of point 1 relative to point 2 (dimensionless). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pS12</td><td>pointer to the area under the geodesic (meters<sup>2</sup>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>a12</em> arc length of between point 1 and point 2 (degrees).</dd></dl>
<p><em>g</em> must have been initialized with a call to <a class="el" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init()</a>. <em>lat1</em> and <em>lat2</em> should be in the range [&minus;90&deg;, 90&deg;]; <em>lon1</em> and <em>lon2</em> should be in the range [&minus;540&deg;, 540&deg;). Any of the "return" arguments <em>ps12</em>, etc., may be replaced by 0, if you do not need some quantities computed. </p>

</div>
</div>
<a id="a85679144e60bddbad4e142c3918d7803" name="a85679144e60bddbad4e142c3918d7803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85679144e60bddbad4e142c3918d7803">&#9670;&#160;</a></span>geod_genposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double geod_genposition </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structgeod__geodesicline.html">geod_geodesicline</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arcmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s12_a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>plat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>plon2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pazi2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ps12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pm12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pM12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pM21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pS12</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The general position function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the <a class="el" href="structgeod__geodesicline.html">geod_geodesicline</a> object specifying the geodesic line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arcmode</td><td>flag determining the meaning of the second parameter; if arcmode is 0, then <em>l</em> must have been initialized with <em>caps</em> |= GEOD_DISTANCE_IN. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s12_a12</td><td>if <em>arcmode</em> is 0, this is the distance between point 1 and point 2 (meters); otherwise it is the arc length between point 1 and point 2 (degrees); it can be negative. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plat2</td><td>pointer to the latitude of point 2 (degrees). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plon2</td><td>pointer to the longitude of point 2 (degrees); requires that <em>l</em> was initialized with <em>caps</em> |= GEOD_LONGITUDE. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pazi2</td><td>pointer to the (forward) azimuth at point 2 (degrees). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ps12</td><td>pointer to the distance between point 1 and point 2 (meters); requires that <em>l</em> was initialized with <em>caps</em> |= GEOD_DISTANCE. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pm12</td><td>pointer to the reduced length of geodesic (meters); requires that <em>l</em> was initialized with <em>caps</em> |= GEOD_REDUCEDLENGTH. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pM12</td><td>pointer to the geodesic scale of point 2 relative to point 1 (dimensionless); requires that <em>l</em> was initialized with <em>caps</em> |= GEOD_GEODESICSCALE. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pM21</td><td>pointer to the geodesic scale of point 1 relative to point 2 (dimensionless); requires that <em>l</em> was initialized with <em>caps</em> |= GEOD_GEODESICSCALE. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pS12</td><td>pointer to the area under the geodesic (meters<sup>2</sup>); requires that <em>l</em> was initialized with <em>caps</em> |= GEOD_AREA. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>a12</em> arc length of between point 1 and point 2 (degrees).</dd></dl>
<p><em>l</em> must have been initialized with a call to <a class="el" href="geodesic_8h.html#a09e376205aa792afe7ab50d6ef7d3435">geod_lineinit()</a> with <em>caps</em> |= GEOD_DISTANCE_IN. The values of <em>lon2</em> and <em>azi2</em> returned are in the range [&minus;180&deg;, 180&deg;). Any of the "return" arguments <em>plat2</em>, etc., may be replaced by 0, if you do not need some quantities computed. Requesting a value which <em>l</em> is not capable of computing is not an error; the corresponding argument will not be altered.</p>
<p >Example, compute way points between JFK and Singapore Changi Airport using <a class="el" href="geodesic_8h.html#a85679144e60bddbad4e142c3918d7803">geod_genposition()</a>. In this example, the points are evenly space in arc length (and so only approximately equally space in distance). This is faster than using <a class="el" href="geodesic_8h.html#a639904c52fc74105d084ec679988ccb6">geod_position()</a> would be appropriate if drawing the path on a map. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structgeod__geodesic.html">geod_geodesic</a> g;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structgeod__geodesicline.html">geod_geodesicline</a> l;</div>
<div class="line"><span class="keywordtype">double</span> a12, <a class="code hl_variable" href="structgeod__geodesicline.html#a1321e3456725622e26f716605d6d02ff">azi1</a>, lat[101],lon[101];</div>
<div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init</a>(&amp;g, 6378137, 1/298.257223563);</div>
<div class="line">a12 = <a class="code hl_function" href="geodesic_8h.html#a73f22c8aef9d1f2a8b13aebea4e8cae3">geod_geninverse</a>(&amp;g, 40.64, -73.78, 1.36, 103.99,</div>
<div class="line">                      0, &amp;<a class="code hl_variable" href="structgeod__geodesicline.html#a1321e3456725622e26f716605d6d02ff">azi1</a>, 0, 0, 0, 0, 0);</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#a09e376205aa792afe7ab50d6ef7d3435">geod_lineinit</a>(&amp;l, &amp;g, 40.64, -73.78, <a class="code hl_variable" href="structgeod__geodesicline.html#a1321e3456725622e26f716605d6d02ff">azi1</a>, <a class="code hl_enumvalue" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6ea4a91360f17ece136774405203fc82a77">GEOD_LATITUDE</a> | <a class="code hl_enumvalue" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6ea31db22e3891097a65a5dbacde93bc9b9">GEOD_LONGITUDE</a>);</div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 101; ++i) {</div>
<div class="line">  <a class="code hl_function" href="geodesic_8h.html#a85679144e60bddbad4e142c3918d7803">geod_genposition</a>(&amp;l, 1, i * a12 * 0.01,</div>
<div class="line">                   lat + i, lon + i, 0, 0, 0, 0, 0, 0);</div>
<div class="line">  printf(<span class="stringliteral">&quot;%.5f %.5f\n&quot;</span>, lat[i], lon[i]);</div>
<div class="line">}</div>
<div class="ttc" id="ageodesic_8h_html_a09e376205aa792afe7ab50d6ef7d3435"><div class="ttname"><a href="geodesic_8h.html#a09e376205aa792afe7ab50d6ef7d3435">geod_lineinit</a></div><div class="ttdeci">void geod_lineinit(struct geod_geodesicline *l, const struct geod_geodesic *g, double lat1, double lon1, double azi1, unsigned caps)</div></div>
<div class="ttc" id="ageodesic_8h_html_a13d1d4e7ad788044ac154396cb8ffa6ea31db22e3891097a65a5dbacde93bc9b9"><div class="ttname"><a href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6ea31db22e3891097a65a5dbacde93bc9b9">GEOD_LONGITUDE</a></div><div class="ttdeci">@ GEOD_LONGITUDE</div><div class="ttdef"><b>Definition:</b> geodesic.h:702</div></div>
<div class="ttc" id="ageodesic_8h_html_a13d1d4e7ad788044ac154396cb8ffa6ea4a91360f17ece136774405203fc82a77"><div class="ttname"><a href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6ea4a91360f17ece136774405203fc82a77">GEOD_LATITUDE</a></div><div class="ttdeci">@ GEOD_LATITUDE</div><div class="ttdef"><b>Definition:</b> geodesic.h:701</div></div>
<div class="ttc" id="ageodesic_8h_html_a73f22c8aef9d1f2a8b13aebea4e8cae3"><div class="ttname"><a href="geodesic_8h.html#a73f22c8aef9d1f2a8b13aebea4e8cae3">geod_geninverse</a></div><div class="ttdeci">double geod_geninverse(const struct geod_geodesic *g, double lat1, double lon1, double lat2, double lon2, double *ps12, double *pazi1, double *pazi2, double *pm12, double *pM12, double *pM21, double *pS12)</div></div>
<div class="ttc" id="ageodesic_8h_html_a85679144e60bddbad4e142c3918d7803"><div class="ttname"><a href="geodesic_8h.html#a85679144e60bddbad4e142c3918d7803">geod_genposition</a></div><div class="ttdeci">double geod_genposition(const struct geod_geodesicline *l, int arcmode, double s12_a12, double *plat2, double *plon2, double *pazi2, double *ps12, double *pm12, double *pM12, double *pM21, double *pS12)</div></div>
<div class="ttc" id="astructgeod__geodesicline_html"><div class="ttname"><a href="structgeod__geodesicline.html">geod_geodesicline</a></div><div class="ttdef"><b>Definition:</b> geodesic.h:159</div></div>
<div class="ttc" id="astructgeod__geodesicline_html_a1321e3456725622e26f716605d6d02ff"><div class="ttname"><a href="structgeod__geodesicline.html#a1321e3456725622e26f716605d6d02ff">geod_geodesicline::azi1</a></div><div class="ttdeci">double azi1</div><div class="ttdef"><b>Definition:</b> geodesic.h:162</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ace6823e6a47719d500f1a063e4255e5f" name="ace6823e6a47719d500f1a063e4255e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6823e6a47719d500f1a063e4255e5f">&#9670;&#160;</a></span>geod_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geod_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize a <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>a pointer to the object to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the equatorial radius (meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the flattening. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19bc3d000428010ad9d8509174e672c9" name="a19bc3d000428010ad9d8509174e672c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bc3d000428010ad9d8509174e672c9">&#9670;&#160;</a></span>geod_inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geod_inverse </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ps12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pazi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pazi2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Solve the inverse geodesic problem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>a pointer to the <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> object specifying the ellipsoid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lat1</td><td>latitude of point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lon1</td><td>longitude of point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lat2</td><td>latitude of point 2 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lon2</td><td>longitude of point 2 (degrees). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ps12</td><td>pointer to the distance between point 1 and point 2 (meters). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pazi1</td><td>pointer to the azimuth at point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pazi2</td><td>pointer to the (forward) azimuth at point 2 (degrees).</td></tr>
  </table>
  </dd>
</dl>
<p><em>g</em> must have been initialized with a call to <a class="el" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init()</a>. <em>lat1</em> and <em>lat2</em> should be in the range [&minus;90&deg;, 90&deg;]; <em>lon1</em> and <em>lon2</em> should be in the range [&minus;540&deg;, 540&deg;). The values of <em>azi1</em> and <em>azi2</em> returned are in the range [&minus;180&deg;, 180&deg;). Any of the "return" arguments <em>ps12</em>, etc., may be replaced by 0, if you do not need some quantities computed.</p>
<p >If either point is at a pole, the azimuth is defined by keeping the longitude fixed, writing <em>lat</em> = &plusmn;(90&deg; &minus; &epsilon;), and taking the limit &epsilon; &rarr; 0+.</p>
<p >The solution to the inverse problem is found using Newton's method. If this fails to converge (this is very unlikely in geodetic applications but does occur for very eccentric ellipsoids), then the bisection method is used to refine the solution.</p>
<p >Example, determine the distance between JFK and Singapore Changi Airport: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structgeod__geodesic.html">geod_geodesic</a> g;</div>
<div class="line"><span class="keywordtype">double</span> s12;</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init</a>(&amp;g, 6378137, 1/298.257223563);</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#a19bc3d000428010ad9d8509174e672c9">geod_inverse</a>(&amp;g, 40.64, -73.78, 1.36, 103.99, &amp;s12, 0, 0);</div>
<div class="line">printf(<span class="stringliteral">&quot;%.3f\n&quot;</span>, s12);</div>
<div class="ttc" id="ageodesic_8h_html_a19bc3d000428010ad9d8509174e672c9"><div class="ttname"><a href="geodesic_8h.html#a19bc3d000428010ad9d8509174e672c9">geod_inverse</a></div><div class="ttdeci">void geod_inverse(const struct geod_geodesic *g, double lat1, double lon1, double lat2, double lon2, double *ps12, double *pazi1, double *pazi2)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a09e376205aa792afe7ab50d6ef7d3435" name="a09e376205aa792afe7ab50d6ef7d3435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e376205aa792afe7ab50d6ef7d3435">&#9670;&#160;</a></span>geod_lineinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geod_lineinit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structgeod__geodesicline.html">geod_geodesicline</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>azi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize a <a class="el" href="structgeod__geodesicline.html">geod_geodesicline</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">l</td><td>a pointer to the object to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>a pointer to the <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> object specifying the ellipsoid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lat1</td><td>latitude of point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lon1</td><td>longitude of point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">azi1</td><td>azimuth at point 1 (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">caps</td><td>bitor'ed combination of <a class="el" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6e">geod_mask()</a> values specifying the capabilities the <a class="el" href="structgeod__geodesicline.html">geod_geodesicline</a> object should possess, i.e., which quantities can be returned in calls to <a class="el" href="geodesic_8h.html#a639904c52fc74105d084ec679988ccb6">geod_position()</a> and <a class="el" href="geodesic_8h.html#a85679144e60bddbad4e142c3918d7803">geod_genposition()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><em>g</em> must have been initialized with a call to <a class="el" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init()</a>. <em>lat1</em> should be in the range [&minus;90&deg;, 90&deg;]; <em>lon1</em> and <em>azi1</em> should be in the range [&minus;540&deg;, 540&deg;).</p>
<p >The geod_mask values are [see <a class="el" href="geodesic_8h.html#a13d1d4e7ad788044ac154396cb8ffa6e">geod_mask()</a>]:</p><ul>
<li><em>caps</em> |= GEOD_LATITUDE for the latitude <em>lat2</em>; this is added automatically,</li>
<li><em>caps</em> |= GEOD_LONGITUDE for the latitude <em>lon2</em>,</li>
<li><em>caps</em> |= GEOD_AZIMUTH for the latitude <em>azi2</em>; this is added automatically,</li>
<li><em>caps</em> |= GEOD_DISTANCE for the distance <em>s12</em>,</li>
<li><em>caps</em> |= GEOD_REDUCEDLENGTH for the reduced length <em>m12</em>,</li>
<li><em>caps</em> |= GEOD_GEODESICSCALE for the geodesic scales <em>M12</em> and <em>M21</em>,</li>
<li><em>caps</em> |= GEOD_AREA for the area <em>S12</em>,</li>
<li><em>caps</em> |= GEOD_DISTANCE_IN permits the length of the geodesic to be given in terms of <em>s12</em>; without this capability the length can only be specified in terms of arc length.</li>
</ul>
<p>A value of <em>caps</em> = 0 is treated as GEOD_LATITUDE | GEOD_LONGITUDE | GEOD_AZIMUTH | GEOD_DISTANCE_IN (to support the solution of the "standard" direct problem). </p>

</div>
</div>
<a id="a18a039bd09181fad7b5238bef1a3a667" name="a18a039bd09181fad7b5238bef1a3a667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a039bd09181fad7b5238bef1a3a667">&#9670;&#160;</a></span>geod_polygon_addedge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geod_polygon_addedge </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structgeod__polygon.html">geod_polygon</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>azi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add an edge to the polygon or polyline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>a pointer to the <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> object specifying the ellipsoid. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>a pointer to the <a class="el" href="structgeod__polygon.html">geod_polygon</a> object specifying the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">azi</td><td>azimuth at current point (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>distance from current point to next point (meters).</td></tr>
  </table>
  </dd>
</dl>
<p><em>g</em> and <em>p</em> must have been initialized with calls to <a class="el" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init()</a> and <a class="el" href="geodesic_8h.html#a35bcc76a7597c0431d7eb1b2a60b5fc5">geod_polygon_init()</a>, respectively. The same <em>g</em> must be used for all the points and edges in a polygon. <em>azi</em> should be in the range [&minus;540&deg;, 540&deg;). This does nothing if no points have been added yet. The <em>lat</em> and <em>lon</em> fields of <em>p</em> give the location of the new vertex. </p>

</div>
</div>
<a id="ae8efc9ecc11362c7ce2b67909d20eeaf" name="ae8efc9ecc11362c7ce2b67909d20eeaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8efc9ecc11362c7ce2b67909d20eeaf">&#9670;&#160;</a></span>geod_polygon_addpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geod_polygon_addpoint </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structgeod__polygon.html">geod_polygon</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add a point to the polygon or polyline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>a pointer to the <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> object specifying the ellipsoid. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>a pointer to the <a class="el" href="structgeod__polygon.html">geod_polygon</a> object specifying the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lat</td><td>the latitude of the point (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lon</td><td>the longitude of the point (degrees).</td></tr>
  </table>
  </dd>
</dl>
<p><em>g</em> and <em>p</em> must have been initialized with calls to <a class="el" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init()</a> and <a class="el" href="geodesic_8h.html#a35bcc76a7597c0431d7eb1b2a60b5fc5">geod_polygon_init()</a>, respectively. The same <em>g</em> must be used for all the points and edges in a polygon. <em>lat</em> should be in the range [&minus;90&deg;, 90&deg;] and <em>lon</em> should be in the range [&minus;540&deg;, 540&deg;).</p>
<p >An example of the use of this function is given in the documentation for <a class="el" href="geodesic_8h.html#a82f0bc17da7f4304b059733917d11c4f">geod_polygon_compute()</a>. </p>

</div>
</div>
<a id="a82f0bc17da7f4304b059733917d11c4f" name="a82f0bc17da7f4304b059733917d11c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f0bc17da7f4304b059733917d11c4f">&#9670;&#160;</a></span>geod_polygon_compute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned geod_polygon_compute </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structgeod__polygon.html">geod_polygon</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the results for a polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>a pointer to the <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> object specifying the ellipsoid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a pointer to the <a class="el" href="structgeod__polygon.html">geod_polygon</a> object specifying the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reverse</td><td>if non-zero then clockwise (instead of counter-clockwise) traversal counts as a positive area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>if non-zero then return a signed result for the area if the polygon is traversed in the "wrong" direction instead of returning the area for the rest of the earth. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pA</td><td>pointer to the area of the polygon (meters<sup>2</sup>); only set if <em>polyline</em> is non-zero in the call to <a class="el" href="geodesic_8h.html#a35bcc76a7597c0431d7eb1b2a60b5fc5">geod_polygon_init()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pP</td><td>pointer to the perimeter of the polygon or length of the polyline (meters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of points.</dd></dl>
<p>Only simple polygons (which are not self-intersecting) are allowed. There's no need to "close" the polygon by repeating the first vertex. Set <em>pA</em> or <em>pP</em> to zero, if you do not want the corresponding quantity returned.</p>
<p >Example, compute the perimeter and area of the geodesic triangle with vertices (0&deg;N,0&deg;E), (0&deg;N,90&deg;E), (90&deg;N,0&deg;E). </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> A, P;</div>
<div class="line"><span class="keywordtype">int</span> n;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structgeod__geodesic.html">geod_geodesic</a> g;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structgeod__polygon.html">geod_polygon</a> p;</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init</a>(&amp;g, 6378137, 1/298.257223563);</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#a35bcc76a7597c0431d7eb1b2a60b5fc5">geod_polygon_init</a>(&amp;p, 0);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#ae8efc9ecc11362c7ce2b67909d20eeaf">geod_polygon_addpoint</a>(&amp;g, &amp;p,  0,  0);</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#ae8efc9ecc11362c7ce2b67909d20eeaf">geod_polygon_addpoint</a>(&amp;g, &amp;p,  0, 90);</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#ae8efc9ecc11362c7ce2b67909d20eeaf">geod_polygon_addpoint</a>(&amp;g, &amp;p, 90,  0);</div>
<div class="line">n = <a class="code hl_function" href="geodesic_8h.html#a82f0bc17da7f4304b059733917d11c4f">geod_polygon_compute</a>(&amp;g, &amp;p, 0, 1, &amp;A, &amp;P);</div>
<div class="line">printf(<span class="stringliteral">&quot;%d %.8f %.3f\n&quot;</span>, n, P, A);</div>
<div class="ttc" id="ageodesic_8h_html_a35bcc76a7597c0431d7eb1b2a60b5fc5"><div class="ttname"><a href="geodesic_8h.html#a35bcc76a7597c0431d7eb1b2a60b5fc5">geod_polygon_init</a></div><div class="ttdeci">void geod_polygon_init(struct geod_polygon *p, int polylinep)</div></div>
<div class="ttc" id="ageodesic_8h_html_a82f0bc17da7f4304b059733917d11c4f"><div class="ttname"><a href="geodesic_8h.html#a82f0bc17da7f4304b059733917d11c4f">geod_polygon_compute</a></div><div class="ttdeci">unsigned geod_polygon_compute(const struct geod_geodesic *g, const struct geod_polygon *p, int reverse, int sign, double *pA, double *pP)</div></div>
<div class="ttc" id="ageodesic_8h_html_ae8efc9ecc11362c7ce2b67909d20eeaf"><div class="ttname"><a href="geodesic_8h.html#ae8efc9ecc11362c7ce2b67909d20eeaf">geod_polygon_addpoint</a></div><div class="ttdeci">void geod_polygon_addpoint(const struct geod_geodesic *g, struct geod_polygon *p, double lat, double lon)</div></div>
<div class="ttc" id="astructgeod__polygon_html"><div class="ttname"><a href="structgeod__polygon.html">geod_polygon</a></div><div class="ttdef"><b>Definition:</b> geodesic.h:178</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a35bcc76a7597c0431d7eb1b2a60b5fc5" name="a35bcc76a7597c0431d7eb1b2a60b5fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bcc76a7597c0431d7eb1b2a60b5fc5">&#9670;&#160;</a></span>geod_polygon_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geod_polygon_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structgeod__polygon.html">geod_polygon</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>polylinep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize a <a class="el" href="structgeod__polygon.html">geod_polygon</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>a pointer to the object to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">polylinep</td><td>non-zero if a polyline instead of a polygon.</td></tr>
  </table>
  </dd>
</dl>
<p>If <em>polylinep</em> is zero, then the sequence of vertices and edges added by <a class="el" href="geodesic_8h.html#ae8efc9ecc11362c7ce2b67909d20eeaf">geod_polygon_addpoint()</a> and <a class="el" href="geodesic_8h.html#a18a039bd09181fad7b5238bef1a3a667">geod_polygon_addedge()</a> define a polygon and the perimeter and area are returned by <a class="el" href="geodesic_8h.html#a82f0bc17da7f4304b059733917d11c4f">geod_polygon_compute()</a>. If <em>polylinep</em> is non-zero, then the vertices and edges define a polyline and only the perimeter is returned by <a class="el" href="geodesic_8h.html#a82f0bc17da7f4304b059733917d11c4f">geod_polygon_compute()</a>.</p>
<p >An example of the use of this function is given in the documentation for <a class="el" href="geodesic_8h.html#a82f0bc17da7f4304b059733917d11c4f">geod_polygon_compute()</a>. </p>

</div>
</div>
<a id="a55b07aebad98323e339656343fa68d2d" name="a55b07aebad98323e339656343fa68d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b07aebad98323e339656343fa68d2d">&#9670;&#160;</a></span>geod_polygon_testedge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned geod_polygon_testedge </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structgeod__polygon.html">geod_polygon</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>azi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the results assuming a tentative final test point is added via an azimuth and distance; however, the data for the test point is not saved. This lets you report a running result for the perimeter and area as the user moves the mouse cursor. Ordinary floating point arithmetic is used to accumulate the data for the test point; thus the area and perimeter returned are less accurate than if <a class="el" href="geodesic_8h.html#a18a039bd09181fad7b5238bef1a3a667">geod_polygon_addedge()</a> and <a class="el" href="geodesic_8h.html#a82f0bc17da7f4304b059733917d11c4f">geod_polygon_compute()</a> are used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>a pointer to the <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> object specifying the ellipsoid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a pointer to the <a class="el" href="structgeod__polygon.html">geod_polygon</a> object specifying the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">azi</td><td>azimuth at current point (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>distance from current point to final test point (meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reverse</td><td>if non-zero then clockwise (instead of counter-clockwise) traversal counts as a positive area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>if non-zero then return a signed result for the area if the polygon is traversed in the "wrong" direction instead of returning the area for the rest of the earth. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pA</td><td>pointer to the area of the polygon (meters<sup>2</sup>); only set if <em>polyline</em> is non-zero in the call to <a class="el" href="geodesic_8h.html#a35bcc76a7597c0431d7eb1b2a60b5fc5">geod_polygon_init()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pP</td><td>pointer to the perimeter of the polygon or length of the polyline (meters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of points.</dd></dl>
<p><em>azi</em> should be in the range [&minus;540&deg;, 540&deg;). </p>

</div>
</div>
<a id="a2d95ee1a89aca82ac8d364ad4163e769" name="a2d95ee1a89aca82ac8d364ad4163e769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d95ee1a89aca82ac8d364ad4163e769">&#9670;&#160;</a></span>geod_polygon_testpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned geod_polygon_testpoint </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structgeod__polygon.html">geod_polygon</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the results assuming a tentative final test point is added; however, the data for the test point is not saved. This lets you report a running result for the perimeter and area as the user moves the mouse cursor. Ordinary floating point arithmetic is used to accumulate the data for the test point; thus the area and perimeter returned are less accurate than if <a class="el" href="geodesic_8h.html#ae8efc9ecc11362c7ce2b67909d20eeaf">geod_polygon_addpoint()</a> and <a class="el" href="geodesic_8h.html#a82f0bc17da7f4304b059733917d11c4f">geod_polygon_compute()</a> are used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>a pointer to the <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> object specifying the ellipsoid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a pointer to the <a class="el" href="structgeod__polygon.html">geod_polygon</a> object specifying the polygon. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lat</td><td>the latitude of the test point (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lon</td><td>the longitude of the test point (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reverse</td><td>if non-zero then clockwise (instead of counter-clockwise) traversal counts as a positive area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>if non-zero then return a signed result for the area if the polygon is traversed in the "wrong" direction instead of returning the area for the rest of the earth. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pA</td><td>pointer to the area of the polygon (meters<sup>2</sup>); only set if <em>polyline</em> is non-zero in the call to <a class="el" href="geodesic_8h.html#a35bcc76a7597c0431d7eb1b2a60b5fc5">geod_polygon_init()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pP</td><td>pointer to the perimeter of the polygon or length of the polyline (meters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of points.</dd></dl>
<p><em>lat</em> should be in the range [&minus;90&deg;, 90&deg;] and <em>lon</em> should be in the range [&minus;540&deg;, 540&deg;). </p>

</div>
</div>
<a id="aafa25f138d78c387a107ec0221bbb181" name="aafa25f138d78c387a107ec0221bbb181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa25f138d78c387a107ec0221bbb181">&#9670;&#160;</a></span>geod_polygonarea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geod_polygonarea </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lats</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lons</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A simple interface for computing the area of a geodesic polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>a pointer to the <a class="el" href="structgeod__geodesic.html">geod_geodesic</a> object specifying the ellipsoid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lats</td><td>an array of latitudes of the polygon vertices (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lons</td><td>an array of longitudes of the polygon vertices (degrees). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number of vertices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pA</td><td>pointer to the area of the polygon (meters<sup>2</sup>). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pP</td><td>pointer to the perimeter of the polygon (meters).</td></tr>
  </table>
  </dd>
</dl>
<p><em>lats</em> should be in the range [&minus;90&deg;, 90&deg;]; <em>lons</em> should be in the range [&minus;540&deg;, 540&deg;).</p>
<p >Only simple polygons (which are not self-intersecting) are allowed. There's no need to "close" the polygon by repeating the first vertex. The area returned is signed with counter-clockwise traversal being treated as positive.</p>
<p >Example, compute the area of Antarctic: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span></div>
<div class="line">  lats[] = {-72.9, -71.9, -74.9, -74.3, -77.5, -77.4, -71.7, -65.9, -65.7,</div>
<div class="line">            -66.6, -66.9, -69.8, -70.0, -71.0, -77.3, -77.9, -74.7},</div>
<div class="line">  lons[] = {-74, -102, -102, -131, -163, 163, 172, 140, 113,</div>
<div class="line">             88, 59, 25, -4, -14, -33, -46, -61};</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structgeod__geodesic.html">geod_geodesic</a> g;</div>
<div class="line"><span class="keywordtype">double</span> A, P;</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init</a>(&amp;g, 6378137, 1/298.257223563);</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#aafa25f138d78c387a107ec0221bbb181">geod_polygonarea</a>(&amp;g, lats, lons, (<span class="keyword">sizeof</span> lats) / (<span class="keyword">sizeof</span> lats[0]), &amp;A, &amp;P);</div>
<div class="line">printf(<span class="stringliteral">&quot;%.0f %.2f\n&quot;</span>, A, P);</div>
<div class="ttc" id="ageodesic_8h_html_aafa25f138d78c387a107ec0221bbb181"><div class="ttname"><a href="geodesic_8h.html#aafa25f138d78c387a107ec0221bbb181">geod_polygonarea</a></div><div class="ttdeci">void geod_polygonarea(const struct geod_geodesic *g, double lats[], double lons[], int n, double *pA, double *pP)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a639904c52fc74105d084ec679988ccb6" name="a639904c52fc74105d084ec679988ccb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639904c52fc74105d084ec679988ccb6">&#9670;&#160;</a></span>geod_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geod_position </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structgeod__geodesicline.html">geod_geodesicline</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>plat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>plon2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pazi2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compute the position along a <a class="el" href="structgeod__geodesicline.html">geod_geodesicline</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>a pointer to the <a class="el" href="structgeod__geodesicline.html">geod_geodesicline</a> object specifying the geodesic line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s12</td><td>distance between point 1 and point 2 (meters); it can be negative. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plat2</td><td>pointer to the latitude of point 2 (degrees). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plon2</td><td>pointer to the longitude of point 2 (degrees); requires that <em>l</em> was initialized with <em>caps</em> |= GEOD_LONGITUDE. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pazi2</td><td>pointer to the (forward) azimuth at point 2 (degrees).</td></tr>
  </table>
  </dd>
</dl>
<p><em>l</em> must have been initialized with a call to <a class="el" href="geodesic_8h.html#a09e376205aa792afe7ab50d6ef7d3435">geod_lineinit()</a> with <em>caps</em> |= GEOD_DISTANCE_IN. The values of <em>lon2</em> and <em>azi2</em> returned are in the range [&minus;180&deg;, 180&deg;). Any of the "return" arguments <em>plat2</em>, etc., may be replaced by 0, if you do not need some quantities computed.</p>
<p >Example, compute way points between JFK and Singapore Changi Airport the "obvious" way using <a class="el" href="geodesic_8h.html#a676f59f07987ddd3dd4109fcfeccdb9d">geod_direct()</a>: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structgeod__geodesic.html">geod_geodesic</a> g;</div>
<div class="line"><span class="keywordtype">double</span> s12, azi1, lat[101],lon[101];</div>
<div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init</a>(&amp;g, 6378137, 1/298.257223563);</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#a19bc3d000428010ad9d8509174e672c9">geod_inverse</a>(&amp;g, 40.64, -73.78, 1.36, 103.99, &amp;s12, &amp;azi1, 0);</div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 101; ++i) {</div>
<div class="line">  <a class="code hl_function" href="geodesic_8h.html#a676f59f07987ddd3dd4109fcfeccdb9d">geod_direct</a>(&amp;g, 40.64, -73.78, azi1, i * s12 * 0.01, lat + i, lon + i, 0);</div>
<div class="line">  printf(<span class="stringliteral">&quot;%.5f %.5f\n&quot;</span>, lat[i], lon[i]);</div>
<div class="line">}</div>
</div><!-- fragment --><p> A faster way using <a class="el" href="geodesic_8h.html#a639904c52fc74105d084ec679988ccb6">geod_position()</a>: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structgeod__geodesic.html">geod_geodesic</a> g;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structgeod__geodesicline.html">geod_geodesicline</a> l;</div>
<div class="line"><span class="keywordtype">double</span> s12, <a class="code hl_variable" href="structgeod__geodesicline.html#a1321e3456725622e26f716605d6d02ff">azi1</a>, lat[101],lon[101];</div>
<div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#ace6823e6a47719d500f1a063e4255e5f">geod_init</a>(&amp;g, 6378137, 1/298.257223563);</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#a19bc3d000428010ad9d8509174e672c9">geod_inverse</a>(&amp;g, 40.64, -73.78, 1.36, 103.99, &amp;s12, &amp;<a class="code hl_variable" href="structgeod__geodesicline.html#a1321e3456725622e26f716605d6d02ff">azi1</a>, 0);</div>
<div class="line"><a class="code hl_function" href="geodesic_8h.html#a09e376205aa792afe7ab50d6ef7d3435">geod_lineinit</a>(&amp;l, &amp;g, 40.64, -73.78, <a class="code hl_variable" href="structgeod__geodesicline.html#a1321e3456725622e26f716605d6d02ff">azi1</a>, 0);</div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 101; ++i) {</div>
<div class="line">  <a class="code hl_function" href="geodesic_8h.html#a639904c52fc74105d084ec679988ccb6">geod_position</a>(&amp;l, i * s12 * 0.01, lat + i, lon + i, 0);</div>
<div class="line">  printf(<span class="stringliteral">&quot;%.5f %.5f\n&quot;</span>, lat[i], lon[i]);</div>
<div class="line">}</div>
<div class="ttc" id="ageodesic_8h_html_a639904c52fc74105d084ec679988ccb6"><div class="ttname"><a href="geodesic_8h.html#a639904c52fc74105d084ec679988ccb6">geod_position</a></div><div class="ttdeci">void geod_position(const struct geod_geodesicline *l, double s12, double *plat2, double *plon2, double *pazi2)</div></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_3c4c7c1a85608ccd561c026bec818e51.html">components</a></li><li class="navelem"><a class="el" href="dir_9d0ee2572b01f1402d3863e1b88f4b1c.html">geodesic</a></li><li class="navelem"><a class="el" href="geodesic_8h.html">geodesic.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
